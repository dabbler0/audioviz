// Generated by CoffeeScript 1.7.1
(function() {
  var Complex, fftw3, fs, pcm, stream, _;

  fftw3 = require('./build/Release/fftw3.node');

  fs = require('fs');

  stream = require('stream');

  pcm = require('./pcm');

  _ = require('underscore');

  Complex = require('./complex').Complex;

  google.load('visualization', '1');

  google.setOnLoadCallback(function() {
    var WINDOW, getPowerTable, input, reader;
    getPowerTable = function(options) {
      var buffer, checkAgain, pending, plan, powerTable, powerTableIndex, timeSinceLastFrame;
      options = _.extend({
        windowSize: 8000,
        stepSize: 1000,
        success: function() {}
      }, options);
      if (options.stream == null) {
        throw new Error('Missing "stream" option.');
      }
      powerTable = [];
      plan = new fftw3.Plan(options.windowSize, true);
      buffer = [];
      timeSinceLastFrame = 0;
      powerTableIndex = 0;
      pending = 0;
      options.stream.on('data', function(number) {
        buffer.push(number);
        if (buffer.length > options.windowSize) {
          buffer.shift();
        }
        timeSinceLastFrame += 1;
        if (timeSinceLastFrame >= options.stepSize && buffer.length === options.windowSize) {
          timeSinceLastFrame = 0;
          (function(powerTableIndex) {
            var data, el, fftBuffer, i, powerSeries;
            pending++;
            fftBuffer = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                el = buffer[_i];
                _results.push(new Complex(el, 0));
              }
              return _results;
            })();
            data = Complex.inflate(plan.execute(Complex.flatten(fftBuffer)));
            powerSeries = (function() {
              var _i, _len, _results;
              _results = [];
              for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
                el = data[i];
                _results.push(el.mag());
              }
              return _results;
            })();
            console.log(powerTableIndex);
            powerTable[powerTableIndex] = powerSeries;
            return pending--;
          })(powerTableIndex);
          return powerTableIndex += 1;
        }
      });
      return options.stream.on('end', checkAgain = function() {
        console.log('GOT DONE', pending);
        if (pending === 0) {
          return options.success(powerTable);
        } else {
          return setTimeout(checkAgain, 1);
        }
      });
    };
    input = fs.createReadStream('audio.wav');
    reader = new pcm.Reader();
    input.pipe(reader);
    WINDOW = 1000;
    return getPowerTable({
      stream: reader,
      windowSize: WINDOW,
      stepSize: WINDOW,
      success: function(powers) {
        var data, frame, i, j, power, surfacePlot, _i, _j, _k, _len, _len1, _ref, _ref1;
        data = new google.visualization.DataTable();
        for (i = _i = 1, _ref = Math.floor(WINDOW / 2) + 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          data.addColumn('number', 'col' + i);
        }
        data.addRows(powers.length);
        for (i = _j = 0, _len = powers.length; _j < _len; i = ++_j) {
          frame = powers[i];
          _ref1 = frame.slice(0, +Math.floor(frame.length / 2) + 1 || 9e9);
          for (j = _k = 0, _len1 = _ref1.length; _k < _len1; j = ++_k) {
            power = _ref1[j];
            data.setValue(i, j, power / (WINDOW * 1000));
          }
        }
        surfacePlot = new greg.ross.visualisation.SurfacePlot(document.getElementById('surfacePlotDiv'));
        return surfacePlot.draw(data, {
          xPos: 50,
          yPos: 0,
          width: 500,
          height: 500,
          colourGradient: [
            {
              red: 0,
              green: 0,
              blue: 255
            }, {
              red: 0,
              green: 255,
              blue: 255
            }, {
              red: 0,
              green: 255,
              blue: 0
            }, {
              red: 255,
              green: 255,
              blue: 0
            }, {
              red: 255,
              green: 0,
              blue: 0
            }
          ],
          fillPolygons: true,
          xTitle: 'X',
          yTitle: 'Y',
          zTitle: 'Z',
          restrictXRotation: false
        });
      }
    });
  });

}).call(this);
